my $BLD_ROOT = $ENV{BLD_ROOT};
die trace ("-E- Environment variable 'BLD_ROOT' does not defined") unless ($BLD_ROOT);
trace ("-D- BLD_ROOT: '$BLD_ROOT'") if $verbose;

my $BIN_ROOT = $ENV{BIN_ROOT};
die trace ("-E- Environment variable 'BIN_ROOT' does not defined") unless ($BIN_ROOT);
trace ("-D- BIN_ROOT: '$BIN_ROOT'") if $verbose;

my $RLS_ROOT = $ENV{RLS_ROOT};
die trace ("-E- Environment variable 'RLS_ROOT' does not defined") unless ($RLS_ROOT);
trace ("-D- RLS_ROOT: '$RLS_ROOT'") if $verbose;

my $STG_ROOT = $ENV{STG_ROOT};
die trace ("-E- Environment variable 'STG_ROOT' does not defined") unless ($STG_ROOT);
trace ("-D- STG_ROOT: '$STG_ROOT'") if $verbose;

 The code starts by defining some environment variables.
 These are used to store the path of the BLD_ROOT, BIN_ROOT, RLS_ROOT, and STG_ROOT directories.
 The code then defines a function called trace().
 This function is used to print out debugging information on the screen.
 The -E- flag tells Perl that this is an error message; it will be printed if there is no value for $BLD_ROOT or $BIN_ROOT or so forth in the environment variable list.
 The -D- flag tells Perl that this should be displayed as debug output (if you want more verbose messages).
 Finally, we use die() to stop execution when an error occurs with our program.
 The code is a Perl script that sets the environment variables BLD_ROOT, BIN_ROOT, RLS_ROOT and STG_ROOT.
 The code first checks if the variable exists in the environment.
 If it does not exist then it will die with an error message.
 If the variable does exist then it will set its value to $BLD_ROOT, $BIN_ROOT, $RLS_ROOT and $STG_ROOT respectively.
 
######################################################################################################################

#######################################################################################################################

my $LOG_ROOT = $ENV{LOG_ROOT};
my $PRODUCT_FAMILY = $ENV{PRODUCT_FAMILY};

my $RLS_TARGET_DIR;
my $RLS_PACKAGE_DIR;
my $BUILD_AREA  = "";
my $RLS_AREA = "";
my $SHARE_PATH = "";

my $BUILD_TYPE = "Release"; # Default Build-Type (can also be: "Debug", "RelWithDebInfo", "MinSizeRel")
my $SKIP_CHECK_OUT = 0;
my $CMAKE_HOME = "";
my $GMAKE_DEFAULT_CMD = "gmake -j 8 install"; 	# 8 threds for compilation
my $BG_MAKE_CMD = "";
my $BG_MAKE_CMD_FULL = "";
my $BG_MAKE_PATH = "";
my $CMAKE_ADD_OPTION = "";
my $CC;

my $time_string;
my $status;
my $PKG_TAR_FILE = "";

my $SOURCE_DIR = "";
my $RELEASE = "";
my $TARGET_BIN4PKG_PATH = "";
my $COMPONENT = "BG" ;


The code starts by declaring some variables.
 The first variable is $LOG_ROOT, which is the root of the log file for this project.
 This will be used to write out any errors that occur during compilation or installation.
 The second variable is $PRODUCT_FAMILY, which defines what type of product we are compiling and installing.
 There are many different types of products available in CMake: Release (default), Debug, RelWithDebInfo, MinSizeRel, etc...
 The third variable is $RLS_TARGET_DIR; this defines where all the files generated by RLS should go when it's done building them.
 It also contains a list of directories that contain source code for our project as well as other dependencies like Boost libraries and Qt headers if they're needed for compilation/installation.
 The fourth variable is $RLS_PACKAGE_DIR; this directory contains all the compiled binaries from our project after RLS has finished its work on them.
 This directory can be deleted once everything has been built successfully so there's no need to keep it around afterwards unless you want to use it again later on with another build target (e.g., debug).
 The fifth variable is $BUILD_
 The code is a simple example of how to set up an environment variable in CMake.
 The code sets the following variables: - $ENV{LOG_ROOT} - The location where the log file will be written to.
 This can be overridden by specifying the LOG_ROOT environment variable when running cmake.
 - $PRODUCT_FAMILY - The family name for this project, which can also be specified as "Unknown" if no product family is defined.
 - $RLS_TARGET_DIR - A directory where RLS targets are stored and compiled into binaries.
 This can be overridden by specifying the RLS_TARGETS environment variable when running cmake
 
 ####################################################################################################################################
 
 ###################################################################################################################################
 
 # ==  F U N C T I O N S  ===============================================

sub analyzeOptions ()
{
   my $this_function = (split /::/, (caller(0))[3])[1];
   my $error = "";

   trace ("-D- Start Function: '$this_function'\n") if $verbose;

   usage() if (not @ARGV);

   for (my $i = 0; $i < @ARGV; $i++)
   {
# Verbose-MODE
      if ($ARGV[$i] =~ /^-d$/i)
      {
         $verbose = 1;
         trace ("-I- Set Verbose mode on.");
         trace ("-D- Verbose: '$verbose'") if $verbose;
      }
# HELP
      elsif ($ARGV[$i] =~ /^-h$/i)
      {
         usage();
      }
# ST_PROJ
      elsif ( ($ARGV[$i] =~ /^-proj$/) or ($ARGV[$i] =~ /^-p$/) )
      {
         $ST_PROJ = $ARGV[++$i];
		 $ST_PROJ = $ENV{ST_PROJ};
         trace ("-D- ST_PROJ: '$ST_PROJ'") if $verbose ;
      }
# ST_VIEW
      elsif ( ($ARGV[$i] =~ /^-view$/) or ($ARGV[$i] =~ /^-v$/) )
      {
         $ST_VIEW = $ARGV[++$i];
         trace ("-D- ST_VIEW: '$ST_VIEW'") if $verbose ;
      }
# ST_LABEL
      elsif ( ($ARGV[$i] =~ /^-label$/) or ($ARGV[$i] =~ /^-l$/) )
      {
         ${ST_LABEL} = $ARGV[++$i];
         trace ("-D- ST_LABEL: '${ST_LABEL}'") if $verbose ;
      }
# CUSTOMER
      elsif ($ARGV[$i] =~ /^-cust$/)
      {
         $CUSTOMER = uc $ARGV[++$i];
         trace ("-D- CUSTOMER: '$CUSTOMER'") if $verbose ;
      }
# CLEAN BUILD
      elsif ($ARGV[$i] =~ /^-clean$/i)
      {
         $CLEAN_BUILD = 1;
         trace ("-I- Set 'CLEAN_BUILD' flag on\n");
         trace ("-D- CLEAN_BUILD: '$CLEAN_BUILD'") if $verbose ;
      }
# Skip CHECKOUT
      elsif ($ARGV[$i] =~ /^-co$/i)
      {
         $SKIP_CHECK_OUT = 1;
         trace ("-I- Set 'SKIP_CHECK_OUT' flag ON\n");
         trace ("-D- SKIP_CHECK_OUT: '$SKIP_CHECK_OUT'") if $verbose ;
      }
# BUILD TYPE
      elsif ($ARGV[$i] =~ /^-type$/i)
      {
         $BUILD_TYPE = $ARGV[++$i];
         trace ("-D- BUILD_TYPE: '$BUILD_TYPE'") if $verbose ;
      }
# Unknown Parameter
      else
      {
         $error .= "-E- Unknown Parameter: '$ARGV[$i]'\n"
      }

   }

   $error .= "-E- Missing ST View name (-v)\n"  unless ${ST_VIEW};
   $error .= "-E- Missing ST Label name (-l)\n"    unless ${ST_LABEL};
   $error .= "-E- Missing Customer name (-cust)\n"    unless ${CUSTOMER};
   
   if ( $ENV{CLEAN_BUILD} eq "true" )
	{
        $CLEAN_BUILD = "1";	# if defined "-e" the build will run with clean
		trace ("-I- Set 'CLEAN_BUILD' flag on\n");
    } else 
	{
        $CLEAN_BUILD = "0";
    }
	trace ("-D- CLEAN_BUILD: '$CLEAN_BUILD'") if $verbose ;
	
   if ((${SKIP_CHECK_OUT}) and (${CLEAN_BUILD}))
   {
      $error .= "-E- Cannot Skip Checkout (-co) when running a Clean Build (-clean)";
   };

   usage ($error) if ($error);
}

 The code starts by setting the verbose mode to 1.
 This is done with the -I- switch.
 The next line of code prints out a message that says "Set Verbose mode on."
 The -D- switch sets the debug mode, which will print out all function calls and their arguments in addition to any other debugging information.
 Next, we have a loop that goes through each argument passed into this program.
 If it starts with "-d-" then it means that you want to set the debug mode for this particular argument (which is what we did earlier).
 The code is meant to set the verbose mode on.
 -D- Start Function: '$this_function' -I- Set Verbose mode on.
 The code starts by checking for the -h or --help option.
 If it is found, then a usage message is printed and the program exits.
 Next, if $ARGV[$i] contains either "-"D-proj" or "-p", then ST_PROJ will be set to whatever was in $ARGV[++$i].
 The same goes for ST_VIEW and ST_LABEL.
 Finally, CUSTOMER will be set to whatever was in $ARGV[++$i].
 The code attempts to be a generic script that will output the name of the command-line arguments and their corresponding values.
 The first if statement is used to determine whether or not the user has entered a -h option.
 If they have, then it prints out usage information.
 The next if statement checks for any of the following: -proj, -p, or -view options.
 If one of these options are found, then it sets ST_PROJ to whatever was passed in as an argument and prints out its value with a trace statement that includes "D-" before it so that you know this is something being changed from within your code (i.e., change from within your program).
 It also prints out "
 The code starts by checking for the -clean flag.
 If it is set, then a trace message will be printed to the screen and the code will continue on with other flags.
 If there is no -clean flag, then the next check is for a parameter called SKIP_CHECKOUT.
 If that parameter exists, then a trace message will be printed to the screen and this line of code will continue on with other flags.
 The final check in this section of code checks for an unknown parameter called BUILD_TYPE.
 If it exists, then a trace message will be printed to the screen and this line of code continues on with other flags.
 The code is a function that will be called from within the main script.
 The code will take in a single parameter, which is the command line arguments.
 The first if statement checks to see if the command line argument is "-clean".
 If it is, then it sets the "CLEAN_BUILD" flag on and prints out a message saying so.
 Then, after printing out that message, it prints out another message saying "-D- CLEAN_BUILD: '$CLEAN_BUILD'".
 This indicates that this particular build type has been set to "CLEAN".
 Next up, we have an elif statement checking for "-co", which would indicate that we are trying to checkout a project.
 In
 The code starts by checking to see if the environment variable CLEAN_BUILD is set.
 If it is, then the build will run with clean trace("-I- Set 'CLEAN_BUILD' flag on\n"); else $CLEAN_BUILD = "0"; The code then checks for a ST View name and a ST Label name.
 The variables ${ST_VIEW} and ${ST_LABEL} are defined in this script.
 if ( $ENV{CLEAN_BUILD} eq "true" ) { $CLEAN_BUILD = "1"; # if defined "-e" the build will run with clean trace ("-I- Set 'CLEAN_BUILD' flag on\n"); } else { $error .= "-E- Missing ST View name (-v)\n" unless ${ST_VIEW}; }
 The code will run if the variable CLEAN_BUILD is set to 1.
 If CLEAN_BUILD is not set, the code will run if defined "-e".

#######################################################################################################################################

######################################################################################################################################

sub usage ()
{
   my ($error) = @_;
   my $this_function = (split /::/, (caller(0))[3])[1];
   trace ("-D- Start Function: '$this_function'") if $verbose;

   print("\nPlease insert parameters according to the usage guide:\n");

   print "\n$error" if $error;

   my $usage = <<USAGE;

   Usage:
   $0 -h |
      -v <ST_VIEW> -l <ST_LABEL> -cust <CUSTOME_NAME> [-clean] [-co] [-type] [-d]

   -h : Help

   -v 	   : ST View Name
   -l 	   : ST Label Name
   -cust   : [CITI | ABSA | ANZ | BOI | BRCL | BTMU | FNMA | HSBC | LTSB | INVESTEC | MANT | RI | UBIS | UCBP | FNB] Customer Name
   -clean  : Delete objects and executables before compilation
   -co	   : Skip Check out files from ST (DEFAULT is to check-out files)
   -type   : Build Type (DEFAULT is to run the build in 'Debug' mode)
   -d      : Debug Mode

USAGE

    print "$usage";

    trace ("-D- End Function: '$this_function'") if $verbose;
    die ("\n");
}

 The code starts by calling the usage function.
 The usage function prints out a message that says "Please insert parameters according to the usage guide."
 The code then calls the $0 parameter, which is an empty string in this case.
 This means that it will print out a message saying "Usage: $0 -h |" and then end with a line break.
 The next line of code is where we call our main function, which is called $this_function .
 We use split to separate the first three characters from caller(0) , which are ST .
 Then we take those three characters and put them into an array using (caller(0))[3] .
 The third element in this array will be 1 because there are only two elements in caller(0) , so 3 would be 2 if you were counting from 0 instead of 1.
 So what does (caller(0))[1] do?
 It takes whatever was at index one in caller(0) and puts it into variable $this_function .
 In other words, it's taking whatever was at index one on the stack when our program started running and putting it into variable $this_function .
 The code is a function that will output a usage guide for the user to follow.
 The code starts by printing out the usage guide in text form and then ends with an error message if there was one.
 
 ###########################################################################################################################
 
 ##########################################################################################################################
 
 sub Duration($)
{
   # converts duration in seconds in human-friendly format: hours and minutes and seconds
   my $d = shift;
   my $h;
   my $m;
   my $s;
   my $r;

   eval {  $h = $d/3600.} ;

   if ($h > 1)
   {
      $h = int($h);
      $d = $d - ($h * 3600.);
   }
   else
   {
      $h = 0;
   }

   eval { $m = $d / 60. };

   if ( $m > 1)
   {
      $m = int($m);
      $d = $d - ($m * 60.);
   }
   else
   {
      $m = 0;
   }

   $d = int($d);

   my $h_ss = "";
   $h_ss = "$h hours and " if $h;

   my $m_ss = "";
   $m_ss = "$m minutes and " if $m;

   my $d_ss = "";
   $d_ss = "$d seconds" if $d;

   $r = $h_ss . $m_ss . $d_ss ;
   return $r;
}

  
  
  The code converts the duration in seconds to a human-friendly format.
 It does this by dividing the time by 3600, which is then multiplied by 60.
 The result of that multiplication is divided again by 60 and then converted into minutes and seconds.
 The code would convert the duration in seconds to hours, minutes and seconds.
 
 ###############################################################################################################
 
 #############################################################################################################
 
 sub checkMagicLinks($)
{
   my $this_function = (split /::/, (caller(0))[3])[1];
   trace ("-D- Function: '$this_function' - Begin") if $verbose;

   # ----- skip if mistakeously we came here from AIX ---------------------------
   my $local_OS = shift;
   if ($local_OS =~ /solaris/i)
   {
      my $pwd = getcwd;
      # --- lib xercesc first ------------------
      trace("-I- checking links for xerces\n");
      chdir("${BUILD_AREA}/Extmodul/xercesc/lib/solaris");
      system("ln -s libxerces-c.so.28 libxerces-c.so") unless -l "libxerces-c.so";
      system("ln -s libxerces-depdom.so.28 libxerces-depdom.so") unless -l "libxerces-depdom.so";
      chdir ($pwd);
      # --- libMagic now -----------------------
      trace("-I- checking links for libMagick\n");
      chdir("${BUILD_AREA}/Extmodul/ImageMagick/lib/solaris");
      system("ln -s libMagick++.so.1 libMagick++.so") unless -l "libMagick++.so";
      system("ln -s libMagickCore.so.1 libMagickCore.so") unless -l "libMagickCore.so";
      system("ln -s libMagickWand.so.1 libMagickWand.so") unless -l "libMagickWand.so";
      system("ln -s libjpeg.so libjpeg.so.62 ") unless ((-l "libjpeg.so") and (-f "libjpeg.so.62"));
      system("ln -s libpng.so libpng.so.3") unless ((-l "libpng.so") and (-f "libpng.so.3"));
      system("ln -s libtiff.so libtiff.so.3") unless ((-l  "libtiff.so") and (-f "libtiff.so.3"));
      chdir ($pwd);
   }

   trace ("-D- Function: '$this_function' - End") if $verbose;
}

 The code starts by checking if the function is being called from AIX.
 If it is, then we need to change our directory to the Extmodul/xercesc/lib/solaris directory and run ln -s libxerces-c.so.28 libxerces-c.so .
 We also need to do this for xercesc's dependencies: ln -s libxerces-depdom.so.28 libxerces-depdom.so , ln -s libMagick++.so.1 libMagick++.so , and so on until we get back up into BUILD_AREA .
 If it isn't coming from AIX, then we check for links in the local OS before changing directories into BUILD_AREA .
 The code is used to check if the user is on AIX and if so, it will skip all of the links.
 The code checks for xercesc first and then libMagick++.so, libMagickCore.so, libMagickWand.so, libjpeg.so, libpng.so and finally
 
 ####################################################################################################################################
